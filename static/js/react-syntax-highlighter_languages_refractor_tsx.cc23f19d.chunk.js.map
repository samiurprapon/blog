{"version":3,"sources":["../node_modules/refractor/lang/typescript.js","../node_modules/refractor/lang/jsx.js","../node_modules/refractor/lang/tsx.js"],"names":["typescript","Prism","languages","extend","pattern","lookbehind","greedy","inside","builtin","keyword","push","typeInside","insertBefore","decorator","at","alias","function","generic","ts","module","exports","displayName","aliases","jsx","javascript","util","clone","space","source","braces","spread","re","flags","replace","RegExp","tag","script","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","openedBraces","plainText","splice","Token","hooks","add","env","language","refractorJsx","require","refractorTypescript","tsx","register"],"mappings":"wGAKA,SAASA,EAAWC,IACjB,SAAWA,GACVA,EAAMC,UAAUF,WAAaC,EAAMC,UAAUC,OAAO,aAAc,CAChE,aAAc,CACZC,QACE,+KACFC,YAAY,EACZC,QAAQ,EACRC,OAAQ,MAEVC,QACE,0FAEJP,EAAMC,UAAUF,WAAWS,QAAQC,KACjC,mEAEA,gGAEKT,EAAMC,UAAUF,WAAhB,UACP,IAAIW,EAAaV,EAAMC,UAAUC,OAAO,aAAc,WAC/CQ,EAAW,cAClBV,EAAMC,UAAUF,WAAW,cAAcO,OAASI,EAClDV,EAAMC,UAAUU,aAAa,aAAc,WAAY,CACrDC,UAAW,CACTT,QAAS,qBACTG,OAAQ,CACNO,GAAI,CACFV,QAAS,KACTW,MAAO,YAETC,SAAU,aAGd,mBAAoB,CAElBZ,QACE,yGACFE,QAAQ,EACRC,OAAQ,CACNS,SAAU,4DACVC,QAAS,CACPb,QAAS,WAETW,MAAO,aACPR,OAAQI,OAKhBV,EAAMC,UAAUgB,GAAKjB,EAAMC,UAAUF,WAhDtC,CAiDEC,GArDLkB,EAAOC,QAAUpB,EACjBA,EAAWqB,YAAc,aACzBrB,EAAWsB,QAAU,CAAC,O,iCCCtB,SAASC,EAAItB,IACV,SAAWA,GACV,IAAIuB,EAAavB,EAAMwB,KAAKC,MAAMzB,EAAMC,UAAUsB,YAC9CG,EAAQ,+CAA+CC,OACvDC,EAAS,+CAA+CD,OACxDE,EAAS,uCAAuCF,OAKpD,SAASG,EAAGH,EAAQI,GAWlB,OAVAJ,EAASA,EACNK,QAAQ,QAAQ,WACf,OAAON,KAERM,QAAQ,aAAa,WACpB,OAAOJ,KAERI,QAAQ,aAAa,WACpB,OAAOH,KAEJI,OAAON,EAAQI,GAExBF,EAASC,EAAGD,GAAQF,OACpB3B,EAAMC,UAAUqB,IAAMtB,EAAMC,UAAUC,OAAO,SAAUqB,GACvDvB,EAAMC,UAAUqB,IAAIY,IAAI/B,QAAU2B,EAChC,wIACGH,QAEL3B,EAAMC,UAAUqB,IAAIY,IAAI5B,OAAxB,IAAsCH,QAAU,kBAChDH,EAAMC,UAAUqB,IAAIY,IAAI5B,OAAO,cAAcH,QAC3C,sEACFH,EAAMC,UAAUqB,IAAIY,IAAI5B,OAAxB,IAAsCA,OAAO,cAC3C,4BACFN,EAAMC,UAAUqB,IAAIY,IAAI5B,OAAxB,QAA4CiB,EAAU,QACtDvB,EAAMC,UAAUU,aACd,SACA,YACA,CACEkB,OAAQ,CACN1B,QAAS2B,EAAG,WAAWH,QACvBrB,OAAQN,EAAMC,UAAUqB,MAG5BtB,EAAMC,UAAUqB,IAAIY,KAEtBlC,EAAMC,UAAUU,aACd,SACA,eACA,CACEwB,OAAQ,CAENhC,QAAS2B,EAAG,YAAYH,QACxBrB,OAAQ,CACN,qBAAsB,CACpBH,QAAS,WACTW,MAAO,eAETsB,KAAMpC,EAAMC,UAAUqB,KAExBR,MAAO,wBAGXd,EAAMC,UAAUqB,IAAIY,KAEtB,IAAIG,EAAiB,SAAjBA,EAA2BC,GAC7B,OAAKA,EAGgB,kBAAVA,EACFA,EAEoB,kBAAlBA,EAAMC,QACRD,EAAMC,QAERD,EAAMC,QAAQC,IAAIH,GAAgBI,KAAK,IARrC,IAUPC,EAAa,SAAbA,EAAuBC,GAEzB,IADA,IAAIC,EAAa,GACRC,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAAK,CACtC,IAAIP,EAAQK,EAAOE,GACfE,GAAiB,EAgDrB,GA/CqB,kBAAVT,IAEQ,QAAfA,EAAMU,MACNV,EAAMC,QAAQ,IACY,QAA1BD,EAAMC,QAAQ,GAAGS,KAG2B,OAAxCV,EAAMC,QAAQ,GAAGA,QAAQ,GAAGA,QAG5BK,EAAWE,OAAS,GACpBF,EAAWA,EAAWE,OAAS,GAAGG,UAChCZ,EAAeC,EAAMC,QAAQ,GAAGA,QAAQ,KAG1CK,EAAWM,MAG2C,OAApDZ,EAAMC,QAAQD,EAAMC,QAAQO,OAAS,GAAGP,SAI1CK,EAAWnC,KAAK,CACdwC,QAASZ,EAAeC,EAAMC,QAAQ,GAAGA,QAAQ,IACjDY,aAAc,IAKpBP,EAAWE,OAAS,GACL,gBAAfR,EAAMU,MACY,MAAlBV,EAAMC,QAGNK,EAAWA,EAAWE,OAAS,GAAGK,eAElCP,EAAWE,OAAS,GACpBF,EAAWA,EAAWE,OAAS,GAAGK,aAAe,GAClC,gBAAfb,EAAMU,MACY,MAAlBV,EAAMC,QAGNK,EAAWA,EAAWE,OAAS,GAAGK,eAElCJ,GAAiB,IAGjBA,GAAmC,kBAAVT,IAEzBM,EAAWE,OAAS,GAC+B,IAAnDF,EAAWA,EAAWE,OAAS,GAAGK,aAClC,CAGA,IAAIC,EAAYf,EAAeC,GAE7BO,EAAIF,EAAOG,OAAS,IACM,kBAAlBH,EAAOE,EAAI,IACM,eAAvBF,EAAOE,EAAI,GAAGG,QAEhBI,GAAaf,EAAeM,EAAOE,EAAI,IACvCF,EAAOU,OAAOR,EAAI,EAAG,IAGrBA,EAAI,IACsB,kBAAlBF,EAAOE,EAAI,IACM,eAAvBF,EAAOE,EAAI,GAAGG,QAEhBI,EAAYf,EAAeM,EAAOE,EAAI,IAAMO,EAC5CT,EAAOU,OAAOR,EAAI,EAAG,GACrBA,KAEFF,EAAOE,GAAK,IAAI7C,EAAMsD,MACpB,aACAF,EACA,KACAA,GAIFd,EAAMC,SAAoC,kBAAlBD,EAAMC,SAChCG,EAAWJ,EAAMC,WAIvBvC,EAAMuD,MAAMC,IAAI,kBAAkB,SAAUC,GACrB,QAAjBA,EAAIC,UAAuC,QAAjBD,EAAIC,UAGlChB,EAAWe,EAAId,WA1KlB,CA4KE3C,GAhLLkB,EAAOC,QAAUG,EACjBA,EAAIF,YAAc,MAClBE,EAAID,QAAU,I,iCCHd,IAAIsC,EAAeC,EAAQ,KACvBC,EAAsBD,EAAQ,KAIlC,SAASE,EAAI9D,GACXA,EAAM+D,SAASJ,GACf3D,EAAM+D,SAASF,GACd,SAAW7D,GACV,IAAID,EAAaC,EAAMwB,KAAKC,MAAMzB,EAAMC,UAAUF,YAClDC,EAAMC,UAAU6D,IAAM9D,EAAMC,UAAUC,OAAO,MAAOH,GAGpD,IAAImC,EAAMlC,EAAMC,UAAU6D,IAAI5B,IAC9BA,EAAI/B,QAAU8B,OACZ,qBAAqBN,OAAS,MAAQO,EAAI/B,QAAQwB,OAAS,IAC3DO,EAAI/B,QAAQ4B,OAEdG,EAAI9B,YAAa,EAVlB,CAWEJ,GAjBLkB,EAAOC,QAAU2C,EACjBA,EAAI1C,YAAc,MAClB0C,EAAIzC,QAAU","file":"static/js/react-syntax-highlighter_languages_refractor_tsx.cc23f19d.chunk.js","sourcesContent":["'use strict'\n\nmodule.exports = typescript\ntypescript.displayName = 'typescript'\ntypescript.aliases = ['ts']\nfunction typescript(Prism) {\n  ;(function (Prism) {\n    Prism.languages.typescript = Prism.languages.extend('javascript', {\n      'class-name': {\n        pattern:\n          /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n      },\n      builtin:\n        /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/\n    }) // The keywords TypeScript adds to JavaScript\n    Prism.languages.typescript.keyword.push(\n      /\\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n      // eslint-disable-next-line regexp/no-dupe-characters-character-class\n      /\\b(?:asserts|infer|interface|module|namespace|type)(?!\\s*[^\\s_${}*a-zA-Z\\xA0-\\uFFFF])/\n    ) // doesn't work with TS because TS is too complex\n    delete Prism.languages.typescript['parameter'] // a version of typescript specifically for highlighting types\n    var typeInside = Prism.languages.extend('typescript', {})\n    delete typeInside['class-name']\n    Prism.languages.typescript['class-name'].inside = typeInside\n    Prism.languages.insertBefore('typescript', 'function', {\n      decorator: {\n        pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n        inside: {\n          at: {\n            pattern: /^@/,\n            alias: 'operator'\n          },\n          function: /^[\\s\\S]+/\n        }\n      },\n      'generic-function': {\n        // e.g. foo<T extends \"bar\" | \"baz\">( ...\n        pattern:\n          /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n        greedy: true,\n        inside: {\n          function: /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n          generic: {\n            pattern: /<[\\s\\S]+/,\n            // everything after the first <\n            alias: 'class-name',\n            inside: typeInside\n          }\n        }\n      }\n    })\n    Prism.languages.ts = Prism.languages.typescript\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = jsx\njsx.displayName = 'jsx'\njsx.aliases = []\nfunction jsx(Prism) {\n  ;(function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source\n    /**\n     * @param {string} source\n     * @param {string} [flags]\n     */\n    function re(source, flags) {\n      source = source\n        .replace(/<S>/g, function () {\n          return space\n        })\n        .replace(/<BRACES>/g, function () {\n          return braces\n        })\n        .replace(/<SPREAD>/g, function () {\n          return spread\n        })\n      return RegExp(source, flags)\n    }\n    spread = re(spread).source\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = re(\n      /<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n        .source\n    )\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i\n    Prism.languages.jsx.tag.inside['attr-value'].pattern =\n      /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/i\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =\n      /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\n    Prism.languages.jsx.tag.inside['comment'] = javascript['comment']\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: re(/<SPREAD>/.source),\n          inside: Prism.languages.jsx\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'special-attr',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: re(/=<BRACES>/.source),\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?=\\{)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          },\n          alias: 'language-javascript'\n        }\n      },\n      Prism.languages.jsx.tag\n    ) // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n","'use strict'\nvar refractorJsx = require('./jsx.js')\nvar refractorTypescript = require('./typescript.js')\nmodule.exports = tsx\ntsx.displayName = 'tsx'\ntsx.aliases = []\nfunction tsx(Prism) {\n  Prism.register(refractorJsx)\n  Prism.register(refractorTypescript)\n  ;(function (Prism) {\n    var typescript = Prism.util.clone(Prism.languages.typescript)\n    Prism.languages.tsx = Prism.languages.extend('jsx', typescript) // This will prevent collisions between TSX tags and TS generic types.\n    // Idea by https://github.com/karlhorky\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n    var tag = Prism.languages.tsx.tag\n    tag.pattern = RegExp(\n      /(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')',\n      tag.pattern.flags\n    )\n    tag.lookbehind = true\n  })(Prism)\n}\n"],"sourceRoot":""}